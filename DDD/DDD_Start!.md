## 1. 도메인 모델 시작

### 도메인

- `도메인` : 소프트웨어로 해결하고자 하는 문제 영역
- 하나의 도메인은 다시 하위 도메인으로 나눌 수 있다.
    - Ex) '온라인 서점' 도메인은 주문, 회원, 혜택, 카탈로그, 리뷰, 정산, 결제, 배송 등의 하위 도메인으로 나눌 수 있다.

### 도메인 모델

- `도메인 모델` : 특정 도메인을 개념적으로 표현한 것
    - 객체 기반으로 표현한 객체 모델 : 기능과 데이터를 함께 표현할 수 있다.
    - 상태 다이어그램을 활용한 상태 모델링

도메인 모델은 도메인 자체를 이해하기 위한 개념 모델이며, 이를 보고 바로 구현 코드를 작성할 수 있는 것은 아니다.  
따라서 구현 시에는 구현 기술에 맞는 별도의 구현 모델이 따로 필요하다.  
물론 구현 모델이 개념 모델을 최대한 따르도록 할 수는 있다. (객체 기반 모델 → 객체 지향 언어 사용)  

각 하위 도메인이 다루는 영역은 서로 다르기 때문에 같은 용어라도 하위 도메인마다 의미가 달라질 수 있다.  
도메인에 따라 용어의 의미가 결정되므로, 여러 하위 도메인을 하나의 다이어그램에 모델링하면 안 된다.  
즉, 모델의 각 구성요소는 특정 도메인을 한정할 때 비로소 의미가 완전해지기 때문에, 각 하위 도메인마다 별도로 모델을 만들어야 한다.  

### 도메인 모델 패턴

도메인 모델 패턴은 바로 전에서 이야기한 도메인 모델과 조금 다르게, 아키텍처상의 도메인 계층을 객체 지향 기법으로 구현하는 패턴을 의미한다.  
애플리케이션의 아키텍처는 다음과 같다.  

- 사용자 인터페이스(UI), 표현(Presentation)
- 응용(Application)
- 도메인
- 인프라스트럭처(Infrastructure)

### 도메인 모델 도출

도메인을 모델링할 때 기본이 되는 작업은 모델을 구성하는 **핵심 구성요소, 규칙, 기능을 찾는 것**이다.  

### 엔티티와 밸류

도출한 모델은 크게 엔티티(Entity)와 밸류(Value)로 구분할 수 있다.  

- 엔티티
    - 가장 큰 특징은 `식별자` 를 갖는다는 것이다.
        - 엔티티의 식별자는 바뀌지 않고 고유하기 때문에 두 엔티티 객체의 식별자가 같으면 두 엔티티는 같다고 판단할 수 있다. (eq & hc 구현 시 식별자만 비교하도록 구현할 수 있다.)
        - 식별자는 다음 중 한 가지 방식으로 생성한다.
            - 특정 규칙에 따라 생성
            - UUID 사용
            - 값을 직접 입력
            - 일련번호 사용(시퀀스나 DB auto_increment 칼럼 사용)
- 밸류
    - 개념적으로 완전한 하나를 표현할 때 사용한다.
    - 밸류 객체의 데이터를 변경할 때는 기존 데이터를 변경하기보다는 변경한 데이터를 갖는 새로운 밸류 객체를 생성하는 방식을 선호한다. `불변`
        - 불변 객체는 참조 투명성과 스레드 안전한 특징을 갖고 있다.
    - 두 밸류 객체가 같은지 비교할 때는 모든 속성을 비교해야 한다.

도메인 객체가 불완전한 상태로 사용되는 것을 막으려면 setter를 열어두지 말고, 생성 시점에 생성자를 통해 필요한 것을 전달해 주어야 한다.  
생성자에서는 전달받은 데이터의 유효성을 생성 시점에 검사할 수 있다.  

### 도메인 용어

도메인에서 사용하는 용어를 코드에 반영하지 않으면 그 코드는 개발자에게 코드의 의미를 해석해야 하는 부담을 준다.  

## 2. 아키텍처 개요

### 네 개의 영역

아키텍처를 설계할 때 출현하는 전형적인 영역은 다음과 같다.  

- 표현
    - 사용자의 요청을 받아 응용 영역에 전달하고 응용 영역의 처리 결과를 다시 사용자에게 보여주는 역할
    - Spring MVC
    - 사용자는 사람일 수도 있고, 외부 시스템일 수도 있다.
- 응용
    - 시스템이 사용자에게 제공해야 할 기능을 구현
    - 기능을 구현하기 위해 도메인 영역의 도메인 모델을 사용
    - 로직을 직접 수행하기 보다는 도메인 모델에 로직 수행을 위임
- 도메인
    - 도메인 모델을 구현
    - 도메인 모델은 도메인의 핵심 로직을 구현
- 인프라스트럭처
    - 논리적인 개념 보다는 실제 구현 기술에 대한 것들
    - 도메인, 응용, 표현 영역은 구현 기술을 사용한 코드를 직접 만들지 않고, 인프라스트럭처 영역에서 제공하는 기능들을 사용해서 필요한 기능을 개발한다.

### 계층 구조 아키텍처

계층 구조는 그 특성상 상위 계층에서 하위 계층으로의 의존만 존재하고 하위 계층은 상위 계층에 의존하지 않는다.  
예를 들어, 표현은 응용에, 응용은 도메인에 의존하고, 반대로 인프라스트럭처 계층이 도메인에 의존하거나 하지는 않는다.  

하지만, 짚고 넘어가야 할 것이 있는데 바로 표현, 응용, 도메인 계층이 상세한 구현 기술을 다루는 인프라스트럭처 계층에 **종속**된다는 점이다.  
이는 두 가지 문제를 안고 있는데, `테스트가 어렵다` 는 것과 `기능 확장이 어렵다` 는 것이다.  
상위 계층에서 구체적인 구현 기술에 대한 의존을 하고 있으니 실제 테스트가 어려워지고, 구현 기술에 의존적인 만큼 그에 맞추어진 타입, 객체들을 fit하게 만들게 되어 기능 확장을 어렵게 한다.  

이를 해결하기 위해서는 `DIP`를 사용해야 한다.  

### DIP

고수준 모듈이 제대로 동작하려면 저수준 모듈을 사용해야 한다.  
그런데, 고수준 모듈이 저수준 모듈을 사용하면 앞서 계층 구조 아키텍처에서 언급했던 두 가지 문제가 발생한다.  
DIP는 이를 해결하기 위해 저수준 모듈이 고수준 모듈에 의존하도록 바꾼다.  

상위 계층에서는 상위 계층에서 정의한 인터페이스만을 의존하도록 하고, 이 인터페이스를 하위 계층인 인프라스트럭처 계층에서 구현하도록 하는 것이다.  
이러면 위의 두 가지 문제도 쉽게 해결할 수 있다.  
테스트가 어려운 문제는 인터페이스를 구현한 테스트 대역을 사용해 해결할 수 있고, 구현 기술에 대한 의존이 없으니 쉽게 저수준 구현 객체를 갈아끼워서 기능 확장 및 변경에 대처할 수 있게 된다.  

DIP를 잘못 생각하면 인터페이스와 구현 클래스를 분리하는 정도로만 생각할 수 있다.  
그래서 인프라스트럭처 계층에서 정의한 인터페이스를 상위 계층에서 사용하도록 설계할 수 있는데, 이는 올바른 DIP의 형태가 아니다.  
DIP의 핵심은 고수준 모듈이 저수준 모듈에 의존하지 않도록 하기 위한 것이므로, **DIP 적용 시 하위 기능을 추상화한 인터페이스는 고수준 모듈 관점에서 도출**하도록 해야 한다.  

DIP를 적용하게 되면 인프라스트럭처 계층이 반대로 응용 계층과 도메인 계층을 의존하는 구조가 된다.  

### 도메인 영역의 주요 구성요소

- 엔티티와 밸류
    - DB 테이블의 엔티티와 도메인 모델 엔티티의 차이
        - 가장 큰 차이점은 도메인 모델의 엔티티는 데이터와 함께 도메인 기능을 함께 제공한다는 것
            - ex) 주문을 표현하는 엔티티 Order는 주문과 관련된 데이터 뿐만 아니라 배송지 주소 변경을 위한 기능을 함께 제공
        - 또 다른 차이점은 도메인 모델의 엔티티는 두 개 이상의 데이터가 개념적으로 하나인 경우 밸류 타입을 이용해서 표현할 수 있다는 것
- 애그리거트
    - 도메인 모델이 복잡해지면 개발자가 전체 구조가 아닌 각각의 엔티티와 밸류에만 집중하게 된다.
    - 도메인 모델도 개별 객체뿐만 아니라 상위 수준에서 모델을 볼 수 있어야 전체 모델의 관계와 개별 모델을 이해하는 데 도움이 되는데, 이것이 바로 애그리거트이다.
        - AGGREGATE를 애그리게이트라고 표현하면 동사 발음에 해당하므로, 명사 발음인 애그리거트라고 표기한다.
    - 애그리거트를 사용하면 개별 객체가 아닌 관련 객체를 묶어서 객체 군집 단위로 모델을 바라볼 수 있게 된다.
        - ex) 주문 애그리거트는 '주문', '배송지 정보', '주문자', '주문 목록', '총 결제 금액' 등의 하위 모델로 구성된다.
    - 애그리거트는 군집에 속한 객체들을 관리하는 `루트 엔티티`를 갖는다.
        - 루트 엔티티는 애그리거트에 속해 있는 엔티티와 밸류 객체를 이용해서 애그리거트가 구현해야 할 기능을 제공한다.
        - 애그리거트를 사용하는 코드는 애그리거트 루트가 제공하는 기능을 실행하고, 루트를 통해서 간접적으로 애그리거트 내의 다른 엔티티, 밸류 객체에 접근하게 된다. 이는 애그리거트 내부 구현을 숨겨 애그리거트 단위로 구현을 캡슐화할 수 있도록 돕는다.
    - 애그리거트를 어떻게 구성했느냐에 따라 구현이 복잡해지기도 하고 트랜잭션 범위가 달라지기도 한다. 또한 선택한 구현 기술에 따라 애그리거트 구현에 제약이 생기기도 한다.
- 리포지터리
    - 도메인 객체를 지속적으로 사용하려면 물리적인 저장소에 도메인 객체를 보관해야 한다. 이를 위한 도메인 모델이 리포지터리이다.
    - 엔티티나 밸류가 요구사항에서 도출되는 도메인 모델이라면 리포지터리는 구현을 위한 도메인 모델이다.
    - 리포지터리는 애그리거트 단위로 도메인 객체를 저장하고 조회하는 기능을 정의하고, 도메인 모델을 사용해야 하는 코드는 리포지터리를 통해서 도메인 객체를 구한 뒤에 도메인 객체의 기능을 실행하게 된다.
- 도메인 서비스
    - 특정 엔티티에 속하지 않은 도메인 로직을 제공한다. 도메인 로직이 여러 엔티티와 밸류를 필요로 할 경우 도메인 서비스에서 로직을 구현한다.

### 인프라스트럭처 개요

DIP에서 언급한 것처럼 도메인 영역과 응용 영역에서 인프라스트럭처의 기능을 직접 사용하는 것보다 이 두 영역에 정의한 인터페이스를 인프라스트럭처 영역에서 구현하는 것이 시스템을 더 유연하고 테스트하기 쉽게 만들어준다.  

하지만, 무조건 인프라스트럭처에 대한 의존을 없애는 것이 좋은 것은 아니다.  
예를 들어, 트랜잭션 처리를 위해서는 Spring에서 제공하는 `@Transactional` 을 사용하는 것이 편리하다.  
영속성 처리를 위해 JPA를 사용할 경우 `@Entity` 나 `@Table` 같은 JPA 전용 애노테이션을 도메인 모델 클래스에 사용하는 것이 XML 설정을 사용하는 것보다 편리하다.  

DIP의 장점을 해치지 않는 범위에서 응용 영역과 도메인 영역에서 구현 기술에 대한 의존을 가져가는 것이 현명하다.  

### 모듈 구성

패키지 구성 규칙에 정답이 있는 것은 아니다.  

- UI, application, domain, infrastructure 영역별로 모듈이 위치할 패키지를 구성할 수 있다.
- 도메인이 크면 하위 도메인을 나누고 하위 도메인 마다 별도 패키지를 구성할 수 있다.
- domain 모듈은 도메인에 속한 애그리거트를 기준으로 다시 패키지를 구성한다.
